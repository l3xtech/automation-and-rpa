### Somatória dividida por core 1 2 e 3

timeseries { 
  sum(KafkaRequest), 
  value.total = sum(KafkaRequest, scalar: true)
}, filter: matchesPhrase(service.instance.id, "core0")
| sort value.total desc

  sucess






timeseries
  tamanhos.core = avg(KafkaRequest),
  by: {service.instance.id},
filter:
    matchesPhrase(service.instance.id, "core0-small") OR
    matchesPhrase(service.instance.id, "core0-medium") OR
    matchesPhrase(service.instance.id, "core0-huge")
|sort tamanhos.core
| summarize count = count (), by:{service.instance.id}




less






fetch kafka_request
| filter matchesPhrase(service.instance.id, "core0-small") OR
         matchesPhrase(service.instance.id, "core0-medium") OR
         matchesPhrase(service.instance.id, "core0-huge")
| summarize count = count(), by:{service.instance.id}
| sort service.instance.id



error



timeseries
  tamanhos.core = sum(KafkaRequest),
  by: {service.instance.id}
|filter matchesPhrase(service.instance.id, "core0-small") OR
         matchesPhrase(service.instance.id, "core0-medium") OR
         matchesPhrase(service.instance.id, "core0-huge")
| summarize count = count(), by:{service.instance.id}
| sort service.instance.id (edited)
[15:59]




same






// Exemplo de lista de service.instance.id
const serviceInstanceIds = [
  "core0-small",
  "core0-medium",
  "core0-huge",
];

// Função principal
function summarizePods(ids) {
  const counts = {};     // Objeto para contar strings iguais
  const pods = {};       // Objeto para mapear string => podN
  let podNumber = 1;     // Contador de pods sequenciais

  // Contar quantidades de cada string
  ids.forEach(id => {
    counts[id] = (counts[id] || 0) + 1;
  });

  // Criar lista final com nomes de pod e quantidade
  const result = [];

  Object.entries(counts).forEach(([id, count]) => {
    const podName = pod ${podNumber} (${count});
    pods[id] = podName;
    podNumber++;
  });

  // Construir resultado
  ids.forEach(id => {
    result.push({
      original: id,
      pod: pods[id]
    });
  });

  return result;
}

// Executando a função
const summarized = summarizePods(serviceInstanceIds);

// Exibindo o resultado
console.log("Pods resumidos:");
summarized.forEach(entry => {
  console.log(${entry.pod}: ${entry.original});

});
































timeseries
  avgKafkaRequest = avg(KafkaRequest),
  by: {service.instance.id}
| filter matchesPhrase(service.instance.id, "core0-small") OR
         matchesPhrase(service.instance.id, "core0-medium") OR
         matchesPhrase(service.instance.id, "core0-huge")
| summarize
    avgKafkaRequest = avg(avgKafkaRequest),
    count = count(),
    by: {service.instance.id}
| fieldsAdd pod = "pod"
| sort avgKafkaRequest desc























timeseries {
  sum(KafkaRequest)
},
filter: true
| summarize KafkaRequestsTotal = sum(KafkaRequest) by service.instance.id
| sort KafkaRequestsTotal desc









timeseries {
  sum(KafkaRequest)
},
split by service.instance.id
| sort value.total desc









timeseries {
  sum(KafkaRequest),
  split by service.instance.id
}
| sort value.total desc

